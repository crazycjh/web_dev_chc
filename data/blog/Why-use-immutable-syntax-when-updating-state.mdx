---
title: 'Day 7 : Why use immutable syntax when updating state?'
date: '2025-10-28'
lastmod: '2025-10-28'
tags: ['reactjs']
summary: 'Learn why React requires immutable state updates and how reference equality checking works. Understand the difference between primitive and reference comparisons, common pitfalls with object mutations, and best practices for creating new references to trigger re-renders correctly.'
---

import Twemoji from './components/ui/Twemoji';

In React, you always hear: ï¼Šâ€œDonâ€™t mutate state directly.â€*
Is it because Javascript object are call by reference?
Not exactly - the real reason is **React can't detect the change if the reference stays the same.**

### How React check for changes

* **Primitives (numbers, strings, booleans)** â†’ React compares by value.
* **References (objects, arrays)** â†’ React compares by reference (memory address).

React doesn't do deep comparison. it only checks if the value or reference changed

### Primitive Example

```jsx
const [count, setCount] = useState(0);

setCount(1); // new value â†’ React sees change â†’ re-render
setCount(1); // same value â†’ React sees no change â†’ skip
```

ğŸ‘‰ Simple: if the value is new, React re-renders. If itâ€™s the same, React skips.



### Reference Example

```jsx
const [user, setUser] = useState({ name: "Andy" });

// âŒ Wrong: mutate
user.name = "Jack";
setUser(user); // same reference â†’ React canâ€™t detect â†’ no re-render

// âœ… Correct: new reference
setUser({ ...user, name: "Jack" }); // new object â†’ React detects change â†’ re-render
```

ğŸ‘‰ For objects/arrays, React only checks the reference.
Mutating the old object keeps the same reference, so React thinks nothing changed.

### Common Misunderstandings

* **â€œItâ€™s because of call by reference.â€**
  Not exactly. The issue is that React only checks reference equality, not the objectâ€™s inside.
* **â€œImmutable updates are slow.â€**
  They cost a little memory, but guarantee correctness and enable optimizations like `React.memo`


### Practical Use

* Arrays â†’ `setTodos([...todos, newTodo])`
* Objects â†’ `setUser({ ...user, age: 26 })`

### Wrap-Up

* Primitives â†’ compared by value.
* Objects/arrays â†’ compared by reference, no deep comparison.
* Mutating keeps the same reference â†’ React canâ€™t detect.
* Immutable updates create a new reference â†’ React re-renders correctly.