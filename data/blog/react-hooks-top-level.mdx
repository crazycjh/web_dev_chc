---
title: 'Day 9: Why must Hooks be called at the top level?'
date: '2025-11-08'
lastmod: '2025-11-08'
tags: ['react']
summary: ''
---

import Twemoji from './components/ui/Twemoji';

When learning React, you‚Äôve probably heard this rule:

> **Hooks must be called at the top level.**
> **Never put them inside if statements, loops, or conditions!**

But why? Is React just being strict?

üëâ The real reason is that **React relies on the call order to track hook state**.
If the order changes, React loses track, and your component breaks.



## How Hooks Work (Mental Model)

React doesn‚Äôt track hooks by variable name.
Instead, it tracks them by the **order in which they are called**.

You can imagine React keeping an **array of slots** (just a mental model, not the real implementation):

```txt
First render:
slot[0] ‚Üí useState(0)
slot[1] ‚Üí useEffect(...)
slot[2] ‚Üí useState("Andy")

Second render:
React matches them by order:
slot[0] ‚Üí previous count
slot[1] ‚Üí previous effect
slot[2] ‚Üí previous name
```

This ‚Äúarray of slots‚Äù is just for understanding.
Internally, React‚Äôs data structure is more complex, but thinking about it like an ordered list makes it clear:

> **Hooks must always be called in the same order on every render.**



## Why Not in if / loop?

### Wrong Example (if condition)

```jsx
function Counter({ show }) {
  if (show) {
    const [count, setCount] = useState(0); // ‚ùå Only exists when show = true
  }
  const [name, setName] = useState("Andy");
}
```

* When `show=true`: React sees `[count, name]`.
* When `show=false`: React sees `[name]`.
* The slots shift ‚Üí everything breaks.



### Wrong Example (loop)

```jsx
function Example() {
  for (let i = 0; i < 3; i++) {
    const [value, setValue] = useState(i); // ‚ùå Number of hooks changes
  }
  return null;
}
```

React can‚Äôt know how many times that loop runs.
The number of hooks is not consistent ‚Üí mismatch happens.



## The Correct Way

Always declare hooks at the top level, in the same order every time.

```jsx
function Counter({ show }) {
  const [count, setCount] = useState(0);   // ‚úÖ Always slot[0]
  const [name, setName] = useState("Andy"); // ‚úÖ Always slot[1]

  if (!show) return <div>No counter</div>;
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```



## Common Misunderstandings

1. ‚ùå ‚ÄúBut isn‚Äôt it wasteful to call hooks even when I don‚Äôt use them?‚Äù
   ‚úÖ Yes, but this small cost is worth the **predictability**.

2. ‚ùå ‚ÄúCan I call a hook inside a helper function?‚Äù
   ‚úÖ Yes, as long as that function is **always called** in the same way on every render.
   That‚Äôs exactly why **custom hooks** work.



## Quick Practice

Which of these will break?

```jsx
// A
function Example({ show }) {
  if (show) {
    const [count, setCount] = useState(0);
  }
  return null;
}

// B
function Example() {
  const [count, setCount] = useState(0);
  if (count > 0) {
    const [name, setName] = useState("Andy");
  }
  return null;
}

// C
function Example() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

üëâ Answer:

* A ‚ùå
* B ‚ùå
* C ‚úÖ



## Summary

* React tracks hooks by **call order**, not by name.
* Think of it like an **array of slots** that must always align.
* Hooks must always be called in the same order ‚Üí no if, no loops.
* Custom hooks are fine because they‚Äôre still called in a predictable, fixed order.
